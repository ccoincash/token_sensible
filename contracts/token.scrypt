import "util.scrypt";
import "tokenProto.scrypt";
import "txUtil.scrypt";
import "rabinUtil.scrypt";

/**
 * A token protocol based on UTXO model
 */
contract Token {
  int[3] rabinPubKeyArray;
  bytes[3] routeContractCodeHashArray;
  bytes[3] unlockContractCodeHashArray;
  bytes genesisContractHash;

  function verifyAmountCheckContract(
    bytes[3] contractCodeHashArray,
    bytes prevouts,
    int contractInputIndex,
    bytes prevScriptTx,
    int prevScriptOutIndex,
    bytes tokenID,
    bytes tokenCodeHash,
    int nReceivers
  ): bool {
    // verify script
    bytes prevScriptTxId = prevouts[contractInputIndex * TxUtil.OUTPOINT_LEN: contractInputIndex * TxUtil.OUTPOINT_LEN + TxUtil.TX_ID_LEN];
    require(hash256(prevScriptTx) == prevScriptTxId);

    bytes prevScriptCode = TxUtil.readOutputScript(prevScriptTx, prevScriptOutIndex);
    int scriptLen = len(prevScriptCode);

    require(tokenID == prevScriptCode[scriptLen - TokenProto.TOKEN_ID_LEN: scriptLen]);

    require(tokenCodeHash == prevScriptCode[scriptLen - 20 - TokenProto.TOKEN_ID_LEN: scriptLen - TokenProto.TOKEN_ID_LEN]);

    int nReceivers2 = Util.fromLEUnsigned(prevScriptCode[scriptLen - TokenProto.TOKEN_ID_LEN - 20 - 1: scriptLen - 20 - TokenProto.TOKEN_ID_LEN]);
    require(nReceivers2 == nReceivers);

    int pos = TokenProto.TOKEN_ID_LEN + 20 + 1 + TokenProto.TOKEN_ADDRESS_LEN * nReceivers + TokenProto.TOKEN_AMOUNT_LEN * nReceivers;

    // code hash do not count op_return + data length + data
    if (pos < 75) {
      pos += 2;
    } else if (pos < 255) {
      pos += 3;
    } else if (pos < 65536) {
      pos += 4;
    } else {
      pos += 6;
    }

    bytes hash = hash160(prevScriptCode[: scriptLen - pos]);

    return hash == contractCodeHashArray[0] || hash == contractCodeHashArray[1] || hash == contractCodeHashArray[2];
  }

  public function route(
    SigHashPreimage txPreimage,
    PubKey senderPubKey,
    Sig senderSig,
    bytes prevouts,
    bytes rabinMsg,
    bytes[3] rabinPaddingArray,
    int[3] rabinSigArray,
    int contractInputIndex,
    bytes prevScriptTx,
    int prevScriptOutIndex,
    int nReceivers,
    bytes prevTokenAddress,
    int prevTokenAmount
  ) {

    require(Tx.checkPreimage(txPreimage));

    require(hash256(prevouts) == Util.hashPrevouts(txPreimage));

    require(nReceivers > 0);

    bytes tokenScript = Util.scriptCode(txPreimage);
    int scriptLen = len(tokenScript);
    bytes senderAddress = TokenProto.getTokenAddress(tokenScript, scriptLen);
    bytes tokenID = TokenProto.getTokenID(tokenScript, scriptLen);

    bytes code = TokenProto.getContractCode(tokenScript, scriptLen);
    bytes tokenCodeHash = hash160(code);

    // authorize
    require(hash160(senderPubKey) == senderAddress);
    require(checkSig(senderSig, senderPubKey));

    // verify rabin signature
    bytes thisOutpoint = Util.outpoint(txPreimage);
    bool res = RabinUtil.verifyInputMsg(this.rabinPubKeyArray, rabinMsg, rabinPaddingArray, rabinSigArray, thisOutpoint, tokenID, tokenScript, this.genesisContractHash, prevTokenAddress, prevTokenAmount);
    require(res == true);

    res = this.verifyAmountCheckContract(this.routeContractCodeHashArray, prevouts, contractInputIndex, prevScriptTx, prevScriptOutIndex, tokenID, tokenCodeHash, nReceivers);
    require(res == true);
  }

  public function unlockFromContract(
    SigHashPreimage txPreimage,
    bytes prevouts,
    bytes rabinMsg,
    bytes[3] rabinPaddingArray,
    int[3] rabinSigArray,
    bytes prevContractTx,
    int prevContractOutIndex,
    int contractInputIndex,
    bytes checkScriptTx,
    int prevCheckTxOutputIndex,
    int checkScriptInputIndex,
    int nReceivers,
    bytes prevTokenAddress,
    int prevTokenAmount
  ) {
    require(Tx.checkPreimage(txPreimage));
    //require(Tx.checkPreimageOpt(txPreimage));

    // check prevouts
    require(hash256(prevouts) == Util.hashPrevouts(txPreimage));

    // check the script
    bytes tokenScript = Util.scriptCode(txPreimage);
    int scriptLen = len(tokenScript);
    bytes tokenID = TokenProto.getTokenID(tokenScript, scriptLen);
    bytes tokenCodeHash = hash160(TokenProto.getContractCode(tokenScript, scriptLen));

    // verify rabin signature
    bytes thisOutpoint = Util.outpoint(txPreimage);
    bool res = RabinUtil.verifyInputMsg(this.rabinPubKeyArray, rabinMsg, rabinPaddingArray, rabinSigArray, thisOutpoint, tokenID, tokenScript, this.genesisContractHash, prevTokenAddress, prevTokenAmount);
    require(res == true);

    // verify the prevContractTx
    bytes prevScriptTxId = prevouts[contractInputIndex * TxUtil.OUTPOINT_LEN: contractInputIndex * TxUtil.OUTPOINT_LEN + TxUtil.TX_ID_LEN];
    require(hash256(prevContractTx) == prevScriptTxId);

    bytes contractHash = TokenProto.getTokenAddress(tokenScript, scriptLen);

    bytes prevScriptCode = TxUtil.readOutputScript(prevContractTx, prevContractOutIndex);

    require(hash160(prevScriptCode) == contractHash);

    res = this.verifyAmountCheckContract(this.unlockContractCodeHashArray, prevouts, checkScriptInputIndex, checkScriptTx, prevCheckTxOutputIndex, tokenID, tokenCodeHash, nReceivers);
    require(res == true);
  }
}