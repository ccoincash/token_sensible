import "util.scrypt";
import "tokenProto.scrypt";
import "txUtil.scrypt";
import "rabinUtil.scrypt";

/**
 * A token protocol based on UTXO model
 */
contract Token {
  int[3] rabinPubKeyArray;
  bytes routeContractCodeHash;
  bytes unlockContractCodeHash;
  bytes genesisContractHash;

  function verifyAmountCheckContract(
    bytes contractCodeHash,
    bytes prevouts,
    int contractInputIndex,
    bytes prevScriptTx,
    int prevScriptOutIndex,
    bytes tokenID,
    int nReceivers
  ): bool {
    // verify script
    bytes prevScriptTxId = prevouts[contractInputIndex * TxUtil.OUTPOINT_LEN: contractInputIndex * TxUtil.OUTPOINT_LEN + TxUtil.TX_ID_LEN];
    require(hash256(prevScriptTx) == prevScriptTxId);

    bytes prevScriptCode = TxUtil.readOutputScript(prevScriptTx, prevScriptOutIndex);
    int scriptLen = len(prevScriptCode);

    require(tokenID == prevScriptCode[scriptLen - TokenProto.TOKEN_ID_LEN: scriptLen]);

    int nReceivers2 = Util.fromLEUnsigned(prevScriptCode[scriptLen - TokenProto.TOKEN_ID_LEN - 1: scriptLen - TokenProto.TOKEN_ID_LEN]);
    require(nReceivers2 == nReceivers);

    int pos = TokenProto.TOKEN_ID_LEN + 1 + TokenProto.TOKEN_ADDRESS_LEN * nReceivers + TokenProto.TOKEN_AMOUNT_LEN * nReceivers;

    // code hash do not count op_return + data length + data
    if (pos < 75) {
      pos += 2;
    } else if (pos < 255) {
      pos += 3;
    } else if (pos < 65536) {
      pos += 4;
    } else {
      pos += 6;
    }

    bytes contractCode = prevScriptCode[: scriptLen - pos];

    return hash160(contractCode) == contractCodeHash;
  }

  /** 
   * transfer token from n input to n output
   * @function route
   * @param txPreimage {SigHashPreimage} the input preimage
   * @param senderPubKey {PubKey} the signature of sender
   * @param senderSig {Sig} the signature of sender
   * @param nSenders {int} the number of input token utxos
   * @param prevouts {bytes} the previous outputs of tx
   * @param rabinMsgArray {bytes} the msg array with length of nSenders
   * @param rabinPaddingArray {bytes} the padding array with length of nSenders * 3
   * @param rabinSigArray {bytes} the signature array with length of nSenders * 3
   * @param nReceivers {int} the number of token receivers
  */
  public function route(
    SigHashPreimage txPreimage,
    PubKey senderPubKey,
    Sig senderSig,
    bytes prevouts,
    bytes rabinMsg,
    bytes[3] rabinPaddingArray,
    int[3] rabinSigArray,
    int contractInputIndex,
    bytes prevScriptTx,
    int prevScriptOutIndex,
    int nReceivers,
    bytes prevTokenAddress,
    int prevTokenAmount
  ) {

    require(Tx.checkPreimage(txPreimage));

    require(hash256(prevouts) == Util.hashPrevouts(txPreimage));

    // consider the swap pool will remove token when extract liquidity
    require(nReceivers >= 0);

    bytes tokenScript = Util.scriptCode(txPreimage);
    int scriptLen = len(tokenScript);
    bytes senderAddress = TokenProto.getTokenAddress(tokenScript, scriptLen);
    bytes tokenID = TokenProto.getTokenID(tokenScript, scriptLen);

    // authorize
    require(hash160(senderPubKey) == senderAddress);
    require(checkSig(senderSig, senderPubKey));

    bytes thisOutpoint = Util.outpoint(txPreimage);
    // verify rabin signature
    bool res = RabinUtil.verifyInputMsg(this.rabinPubKeyArray, rabinMsg, rabinPaddingArray, rabinSigArray, thisOutpoint, tokenID, tokenScript, this.genesisContractHash, prevTokenAddress, prevTokenAmount);
    require(res == true);

    res = this.verifyAmountCheckContract(this.routeContractCodeHash, prevouts, contractInputIndex, prevScriptTx, prevScriptOutIndex, tokenID, nReceivers);
    require(res == true);
  }

  public function unlockFromContract(
    SigHashPreimage txPreimage,
    bytes prevouts,
    bytes prevContractTx,
    int prevContractOutIndex,
    int contractInputIndex,
    bytes checkScriptTx,
    int prevCheckTxOutputIndex,
    int checkScriptInputIndex,
    int nReceivers
  ) {
    require(Tx.checkPreimage(txPreimage));
    //require(Tx.checkPreimageOpt(txPreimage));

    // check prevouts
    require(hash256(prevouts) == Util.hashPrevouts(txPreimage));

    // verify the prevContractTx
    bytes prevScriptTxId = prevouts[contractInputIndex * TxUtil.OUTPOINT_LEN: contractInputIndex * TxUtil.OUTPOINT_LEN + TxUtil.TX_ID_LEN];
    require(hash256(prevContractTx) == prevScriptTxId);

    // check the script
    bytes lockingScript = Util.scriptCode(txPreimage);
    int scriptLen = len(lockingScript);

    bytes contractHash = TokenProto.getTokenAddress(lockingScript, scriptLen);
    bytes tokenID = TokenProto.getTokenID(lockingScript, scriptLen);

    bytes prevScriptCode = TxUtil.readOutputScript(prevContractTx, prevContractOutIndex);

    require(hash160(prevScriptCode) == contractHash);

    bool res = this.verifyAmountCheckContract(this.unlockContractCodeHash, prevouts, checkScriptInputIndex, checkScriptTx, prevCheckTxOutputIndex, tokenID, nReceivers);
    require(res == true);
  }
}